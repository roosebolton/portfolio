---
layout: post
title: "Maintenance"
---


Het refactoren bewaarde ik voor het einde van het project. Ik downloade ons project en 
maakte er in Github een repo voor aan. Hierna haalde ik het project door bettercodehub.com, 
waarvan het gebruik werd geadviseerd. Hieronder het resultaat:

<img src="{{ '/assets/refactoring/BetterCodeHubStart.svg' | relative_url }}" />


# Bewijsstukken

Als bewijs, lever ik code snippets aan, met voor en na situaties, per richtlijn.

### Write Short Units Of Code
<img src="{{ '/assets/refactoring/WriteShortUnitsOfCodeAnalyzed.svg' | relative_url }}" />

In Bettercodehub zie ik code die ik zelf schreef als voor verbetering vatbaar. Het gaat om 
de wallet.js file. Hierin staat een methode setCointDataForId. Deze methode heeft 40 regels
code. Dat kan beter.

**Voor:**
```javascript
/**
 * Fills one row with the relevant user data
 * @param The asset id, as used in coingecko
 */
const setCoinDataForId = (id, customerData) => {
    let getString = `${coinData}${id}`
    fetch(getString, {
      method: 'GET',
      headers: {},
    })
      .then(response => {
          console.log(response)
          return response.json()
        }
      )
      .then(json => {
        let newRow = document.createElement('tr')
        /////////////////cell1////////////////////
        let newCell1 = document.createElement('td')
        let thumb = document.createElement('img')
        thumb.src = thumbs[id]
        newCell1.appendChild(thumb)
        newRow.appendChild(newCell1)
        ////////////////cell2////////////////////
        let newCell2 = document.createElement('td')
        let code = idToCode[id]
        newCell2.innerHTML = code
        newRow.appendChild(newCell2)
        /////////////////cell3//////////////////
        let newCell3 = document.createElement('td')
        let amount = customerData.assets_in_wallet[code]
        newCell3.innerHTML = amount
        newRow.appendChild(newCell3)
        /////////////////cell4/////////////////
        let newCell4 = document.createElement('td')
        //get latest data from own db
        let currentPrice = currentValues[id]
        newCell4.innerHTML = currencyFormatter("EUR").format(currentPrice)
        newRow.appendChild(newCell4)
        /////////////////cell5/////////////////
        let newCell5 = document.createElement('td')
        let totalValue = currentPrice * amount
        newCell5.innerHTML = currencyFormatter("EUR").format(totalValue)
        newRow.appendChild(newCell5)

        document.getElementById("table-body").appendChild(newRow)
      })
      .catch((error) => {
        console.error('Foutje', error);
      });
  }
```

**Een aantal zaken vallen mij op:**

- De fetch is bij andere methoden in de file tot aan de eerste response compacter.
- Echter: de json die uiteindelijk die uit de fetch response wordt opgeleverd, wordt later niet eens gebruikt.
- Het is duidelijk dat er 5 cellen moeten worden gevuld. Daarvoor moet er vijf keer een tabelcell worden aangemaakt. Dat gebeurt nu in de methode zelf.
- Ook wordt er vijf keer ge-append, ook vijf keer in de methode zelf.

**Conclusie:** 

- Door terugkerende handelingen uit de methode te halen, bijvoorbeeld door hulpfuncties te schrijven,
kan de huidige methode worden ingekort.
- De fetch logica kan helemaal weg.

**Na:**
```javascript
/**
 * Sets content of returnedc tablecell
 * @param cellContent
 * @returns {*}
 */
const returnFullCell = (cellContent) => {
    let newCell = document.createElement(`td`)
    return newCell.appendChild(cellContent)
}

/**
 * Sets innerhtml in returned tablecell
 * @param innerHtml
 * @returns {HTMLTableCellElement}
 */
const returnFullCellWithText = (innerHtml) => {
    let newCell = document.createElement(`td`)
    newCell.innerHTML = innerHtml
    return newCell
}

/**
 * Fills one row with the relevant user data
 * @param The asset id, as used in coingecko
 */
const setCoinDataForId = (id, customerData) => {
            let newRow = document.createElement('tr')
            let thumb = document.createElement('img')
            thumb.src = thumbs[id]
            newRow.appendChild(returnFullCell(thumb))
            newRow.appendChild(returnFullCell(returnFullCellWithText(idToCode[id])))
            let coinAmount = customerData.assets_in_wallet[idToCode[id]]
            newRow.appendChild(returnFullCell(returnFullCellWithText(coinAmount)))
            newRow.appendChild(returnFullCell(returnFullCellWithText(currencyFormatter("EUR").format(currentValues[id]))))
            newRow.appendChild(returnFullCell(returnFullCellWithText(currencyFormatter("EUR").format(currentValues[id] * coinAmount))))
            document.getElementById("table-body").appendChild(newRow)
}
```
**Resultaat:**
Van 40 naar 13 regels code. 

### Write Short Simple Units Of Code
<img src="{{ '/assets/refactoring/WriteSimpleUnitsOfCode2.svg' | relative_url }}" />

In Bettercodehub zie ik geen code die ik zelf schreef voor deze richtlijn. Daarom kies
ik voor verbetering fetchAuth van authModule.js

Voor:

```javascript
/** Custom fetch for using both access and refreshtoken
 * if first fetch with access token fails, it retrieves a new accesstoken via the refreshtoken
 * has ait custom promise which only resolves on correct response
 * it returns the response as promise so that you can customize the desired response*/
const fetchAUTH = (url, options = {}) => {
    let authPromise = new Promise((resolve, reject) => {
      // initiate first fetch to targeted url.
      fetch(url, options)
        .then(response => {
          if (response.ok)   resolve(response)
          if (response.status === 401) {
            /* tries to fetch new accestoken from  */
            fetch(getUrl("refreshTokenAuthAPI"), settingsRefresh("GET"))
              .then(res =>
                res.json())
              .then(json => {
                saveAccesstoken(json.Authorization)
                fetch(url, options).then(response => {
                  if (response.ok) {resolve(response)
                  } else  {
                    response.text().then(text => { reject(text)
                    })
                  }
                }).catch(error => reject(error))
              })
              .catch( error => reject(error))
          } else {reject(response)
          }
        }).catch( error => reject(error))
    })
    return authPromise;
  }
```

**Een aantal zaken vallen mij op:**

- Er is sprake van geneste ifs
- Er is sprake van fetches in fetches
- 
**Conclusie:**
- 
- Het ligt hier voor de hand om de methode kleiner te maken, door verantwoordelijkheden onder te brengen in hulpfuncties

Na:
```javascript
/**
 * Methode om een not authorized eerst op te vangen en te proberen een nieuw accestoken te krijgen.
 * @param status
 * @param response
 * @param url
 * @param options
 */
let handle401 = (status,response,url,options) => {
    if (status) {
        /* tries to fetch new accestoken from  */
        fetch(getUrl("refreshTokenAuthAPI"), settingsRefresh("GET"))
            .then(res =>
                res.json())
            .then(json => {
                saveAccesstoken(json.Authorization)
                fetch(url, options).then(response => {
                    handleResponse(response)
                }).catch(error => reject(error))
            })
            .catch(error => reject(error))
    } else {
        reject(response)
    }
}

/**
 * Hulpmethode om de reactie op een nieuw verzoek tot authorisatie af te handelen in handle401
 * @param response
 */
const handleResponse = (response) =>{
    if (response.ok) {
        resolve(response)
    } else {
        response.text().then(text => {
            reject(text)
        })
    }
}

/** Custom fetch for using both access and refreshtoken
 * if first fetch with access token fails, it retrieves a new accesstoken via the refreshtoken
 * has ait custom promise which only resolves on correct response
 * it returns the response as promise so that you can customize the desired response*/
const fetchAUTH = (url, options = {}) => {
    let authPromise = new Promise((resolve, reject) => {
        // initiate first fetch to targeted url.
        fetch(url, options)
            .then(response => {
                if (response.ok)   resolve(response)
                handle401(response.status===401,response,url,options)
            }).catch( error => reject(error))
    })
    return authPromise;
}

```
**Resultaat:**

De nesting van if else statements in die ene grote functie is sterk teruggebracht. Ze zijn nu over meerder functies verdeeld, wat de score ten goede komt.

### Write Code Once

<img src="{{ '/assets/refactoring/WriteCodeOnce.svg' | relative_url }}" />

In Bettercodehub zie ik code die ik zelf schreef voor deze richtlijn. Het gaat om wallet.js.
Ook zie ik nog mogelijheden bij code die ik niet schreef: login_piratebank.js.

Voor:

Na:

### Keep Unit Interfaces Small

<img src="{{ '/assets/refactoring/KeepUnitInterfacesSmall.svg' | relative_url }}" />

In Bettercodehub zie ik code die ik zelf schreef voor deze richtlijn. Het gaat om de contstructor
van AdminConfigController.java.

Voor:

Na:
### Seperate Concerns in Modules

<img src="{{ '/assets/refactoring/SeperateConcernsInModules.svg' | relative_url }}" />

In Bettercodehub zie ik dat de rootrepository wat betreft deze richtlijn voor verbetering vatbaar is.

Voor:

Na:

### Couple Architecture Components Loosely
<img src="{{ '/assets/refactoring/CoupleArchitectureComponentsLoosely.svg' | relative_url }}" />

In Bettercodehub zie ik dat alles goed is.

Voor:

Na:


### Keep Architecture Components Balanced
<img src="{{ '/assets/refactoring/KeepArchitectureComponentsBalanced.svg' | relative_url }}" />

In Bettercodehub zie ik dat alles goed is.

Voor:

Na:

### Keep Your Codebase Small

<img src="{{ '/assets/refactoring/KeepYourCodebaseSmall.svg' | relative_url }}" />

In Bettercodehub zie ik dat alles goed is.

Voor:

Na:

### Write Clean Code

<img src="{{ '/assets/refactoring/WriteCleanCode.svg' | relative_url }}" />

In Bettercodehub zie ik dat alles goed is.

Voor:

Na:



Om de rubrics in deze module aan te tonen moet je bewijsstukken toevoegen aan je portfolio.


- Laat voor richtlijnen 1 t/m 5 en 10 concrete stukjes code (code-snippets) zien waar je demonstreert hoe je de richtlijnen hebt toegepast en licht je keuzes toe door te laten zien wat er "fout" is en welke refactor-methodes je hebt gebruikt om het op te lossen! Laat daarbij de originele code zien en de gerefactorde code (houdt het wel beknopt, denk aan max 1 pagina per richtlijn!).


- Geef voor richtlijnen 6 t/m 8 in ieder geval een concreet advies hoe je deze guidelines zou toepassen in een concreet stuk code en beargumenteer waarom dat zou werken. Let op, ook als aan de guideline al is voldaan kun je nog steeds een advies geven om het "te verbeteren" of "dat in de toekomst zo te houden". Je mag natuurlijk ook de "concrete" oplossing geven, maar indien dat te veel werk is, mag je dus ook alleen een beargumenteerd advies geven. Wees in je advies wel "concreet", dus adviezen als: "dit stuk code moet je opsplitsen" is niet voldoende, geef concreet aan hoe je het gaat opsplitsen en beschrijf ook de "gevolgen" van zo'n opsplitsing voor andere delen van je code!


- Je mag bovenstaande aantonen met code vanuit je eigen project, of andere code. Bv, umlet, het UML-diagram tekenprogramma staat ook op github en kun je ook door BetterCodeHub laten analyseren.


- Hint: gebruik regelmatig BetterCodeHub op je eigen project.

